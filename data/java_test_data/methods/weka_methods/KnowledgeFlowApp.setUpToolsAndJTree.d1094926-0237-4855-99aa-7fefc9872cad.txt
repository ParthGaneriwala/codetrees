@SuppressWarnings("unchecked")
private void setUpToolsAndJTree() {
    JPanel toolBarPanel = new JPanel();
    toolBarPanel.setLayout(new BorderLayout());
    // first construct the toolbar for saving, loading etc
    if (m_showFileMenu) {
        // set up an action for closing the curren tab
        final Action closeAction = new AbstractAction("Close") {

            /**
             */
            private static final long serialVersionUID = 4762166880144590384L;

            @Override
            public void actionPerformed(ActionEvent e) {
                if (m_mainKFPerspective.getCurrentTabIndex() >= 0) {
                    m_mainKFPerspective.removeTab(getCurrentTabIndex());
                }
            }
        };
        KeyStroke closeKey = KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("Close", closeAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(closeKey, "Close");
        JToolBar fixedTools = new JToolBar();
        fixedTools.setOrientation(JToolBar.HORIZONTAL);
        m_groupB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "bricks.png")));
        m_groupB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_groupB.setToolTipText("Group selected (Ctrl+Z)");
        m_cutB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "cut.png")));
        m_cutB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_cutB.setToolTipText("Cut selected (Ctrl+X)");
        m_copyB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "page_copy.png")));
        m_copyB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_copyB.setToolTipText("Copy selected (Ctrl+C)");
        m_pasteB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "paste_plain.png")));
        m_pasteB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_pasteB.setToolTipText("Paste from clipboard (Ctrl+V)");
        m_deleteB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "delete.png")));
        m_deleteB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_deleteB.setToolTipText("Delete selected (DEL)");
        m_snapToGridB = new JToggleButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "shape_handles.png")));
        // m_snapToGridB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_snapToGridB.setToolTipText("Snap to grid (Ctrl+G)");
        m_saveB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "disk.png")));
        m_saveB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_saveB.setToolTipText("Save layout (Ctrl+S)");
        m_saveBB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "disk_multiple.png")));
        m_saveBB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_saveBB.setToolTipText("Save layout with new name");
        m_loadB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "folder_add.png")));
        m_loadB.setToolTipText("Open (Ctrl+O)");
        m_loadB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_newB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "page_add.png")));
        m_newB.setToolTipText("New layout (Ctrl+N)");
        m_newB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_newB.setEnabled(getAllowMultipleTabs());
        m_helpB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "help.png")));
        m_helpB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_helpB.setToolTipText("Display help (Ctrl+H)");
        m_togglePerspectivesB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "cog_go.png")));
        m_togglePerspectivesB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_togglePerspectivesB.setToolTipText("Show/hide perspectives toolbar (Ctrl+P)");
        m_templatesB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "application_view_tile.png")));
        m_templatesB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_templatesB.setToolTipText("Load a template layout");
        m_noteB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "note_add.png")));
        m_noteB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_noteB.setToolTipText("Add a note to the layout (Ctrl+I)");
        m_selectAllB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "shape_group.png")));
        m_selectAllB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_selectAllB.setToolTipText("Select all (Ctrl+A)");
        m_zoomInB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "zoom_in.png")));
        m_zoomInB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_zoomInB.setToolTipText("Zoom in (Ctrl++)");
        m_zoomOutB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "zoom_out.png")));
        m_zoomOutB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_zoomOutB.setToolTipText("Zoom out (Ctrl+-)");
        m_undoB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "arrow_undo.png")));
        m_undoB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        m_undoB.setToolTipText("Undo (Ctrl+U)");
        fixedTools.add(m_zoomInB);
        fixedTools.add(m_zoomOutB);
        fixedTools.addSeparator();
        fixedTools.add(m_selectAllB);
        fixedTools.add(m_groupB);
        fixedTools.add(m_cutB);
        fixedTools.add(m_copyB);
        fixedTools.add(m_deleteB);
        fixedTools.add(m_pasteB);
        fixedTools.add(m_undoB);
        fixedTools.add(m_noteB);
        fixedTools.addSeparator();
        fixedTools.add(m_snapToGridB);
        fixedTools.addSeparator();
        fixedTools.add(m_newB);
        fixedTools.add(m_saveB);
        fixedTools.add(m_saveBB);
        fixedTools.add(m_loadB);
        fixedTools.add(m_templatesB);
        fixedTools.addSeparator();
        fixedTools.add(m_togglePerspectivesB);
        fixedTools.add(m_helpB);
        Dimension d = m_undoB.getPreferredSize();
        Dimension d2 = fixedTools.getMinimumSize();
        Dimension d3 = new Dimension(d2.width, d.height + 4);
        fixedTools.setPreferredSize(d3);
        fixedTools.setMaximumSize(d3);
        final Action saveAction = new AbstractAction("Save") {

            /**
             */
            private static final long serialVersionUID = 5182044142154404706L;

            @Override
            public void actionPerformed(ActionEvent e) {
                if (m_mainKFPerspective.getCurrentTabIndex() >= 0) {
                    saveLayout(m_mainKFPerspective.getCurrentTabIndex(), false);
                }
            }
        };
        KeyStroke saveKey = KeyStroke.getKeyStroke(KeyEvent.VK_S, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("Save", saveAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(saveKey, "Save");
        m_saveB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                saveAction.actionPerformed(e);
            }
        });
        m_saveBB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                saveLayout(m_mainKFPerspective.getCurrentTabIndex(), true);
            }
        });
        final Action openAction = new AbstractAction("Open") {

            /**
             */
            private static final long serialVersionUID = -5106547209818805444L;

            @Override
            public void actionPerformed(ActionEvent e) {
                m_flowEnvironment = new Environment();
                loadLayout();
            }
        };
        KeyStroke openKey = KeyStroke.getKeyStroke(KeyEvent.VK_O, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("Open", openAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(openKey, "Open");
        m_loadB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                openAction.actionPerformed(e);
            }
        });
        final Action newAction = new AbstractAction("New") {

            /**
             */
            private static final long serialVersionUID = 8002244400334262966L;

            @Override
            public void actionPerformed(ActionEvent e) {
                clearLayout();
            }
        };
        KeyStroke newKey = KeyStroke.getKeyStroke(KeyEvent.VK_N, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("New", newAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(newKey, "New");
        m_newB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent ae) {
                newAction.actionPerformed(ae);
            }
        });
        final Action selectAllAction = new AbstractAction("SelectAll") {

            /**
             */
            private static final long serialVersionUID = -8086754050844707658L;

            @Override
            public void actionPerformed(ActionEvent e) {
                if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() > 0) {
                    // select all beans
                    Vector<Object> allBeans = BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
                    Vector<Object> newSelected = new Vector<Object>();
                    for (int i = 0; i < allBeans.size(); i++) {
                        newSelected.add(allBeans.get(i));
                    }
                    // toggle
                    if (newSelected.size() == m_mainKFPerspective.getSelectedBeans().size()) {
                        // unselect all beans
                        m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
                    } else {
                        // select all beans
                        m_mainKFPerspective.setSelectedBeans(newSelected);
                    }
                }
                revalidate();
                repaint();
                notifyIsDirty();
            }
        };
        KeyStroke selectAllKey = KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("SelectAll", selectAllAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(selectAllKey, "SelectAll");
        m_selectAllB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                selectAllAction.actionPerformed(e);
            }
        });
        final Action zoomInAction = new AbstractAction("ZoomIn") {

            /**
             */
            private static final long serialVersionUID = 1348383794897269484L;

            @Override
            public void actionPerformed(ActionEvent e) {
                m_layoutZoom += 25;
                m_zoomOutB.setEnabled(true);
                if (m_layoutZoom >= 200) {
                    m_layoutZoom = 200;
                    m_zoomInB.setEnabled(false);
                }
                m_mainKFPerspective.setCurrentZoomSetting(m_layoutZoom);
                revalidate();
                repaint();
                notifyIsDirty();
            }
        };
        KeyStroke zoomInKey = KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("ZoomIn", zoomInAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(zoomInKey, "ZoomIn");
        m_zoomInB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                zoomInAction.actionPerformed(e);
            }
        });
        final Action zoomOutAction = new AbstractAction("ZoomOut") {

            /**
             */
            private static final long serialVersionUID = -1120096894263455918L;

            @Override
            public void actionPerformed(ActionEvent e) {
                m_layoutZoom -= 25;
                m_zoomInB.setEnabled(true);
                if (m_layoutZoom <= 50) {
                    m_layoutZoom = 50;
                    m_zoomOutB.setEnabled(false);
                }
                m_mainKFPerspective.setCurrentZoomSetting(m_layoutZoom);
                revalidate();
                repaint();
                notifyIsDirty();
            }
        };
        KeyStroke zoomOutKey = KeyStroke.getKeyStroke(KeyEvent.VK_MINUS, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("ZoomOut", zoomOutAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(zoomOutKey, "ZoomOut");
        m_zoomOutB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                zoomOutAction.actionPerformed(e);
            }
        });
        final Action groupAction = new AbstractAction("Group") {

            /**
             */
            private static final long serialVersionUID = -5752742619180091435L;

            @Override
            public void actionPerformed(ActionEvent e) {
                final Vector<Object> selected = m_mainKFPerspective.getSelectedBeans();
                final Vector<Object> inputs = BeanConnection.inputs(selected, m_mainKFPerspective.getCurrentTabIndex());
                final Vector<Object> outputs = BeanConnection.outputs(selected, m_mainKFPerspective.getCurrentTabIndex());
                groupSubFlow(selected, inputs, outputs);
            }
        };
        KeyStroke groupKey = KeyStroke.getKeyStroke(KeyEvent.VK_Z, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("Group", groupAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(groupKey, "Group");
        m_groupB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                groupAction.actionPerformed(e);
            }
        });
        final Action cutAction = new AbstractAction("Cut") {

            /**
             */
            private static final long serialVersionUID = -4955878102742013040L;

            @Override
            public void actionPerformed(ActionEvent e) {
                // only delete if our copy was successful!
                if (copyToClipboard()) {
                    deleteSelectedBeans();
                }
            }
        };
        KeyStroke cutKey = KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("Cut", cutAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(cutKey, "Cut");
        m_cutB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                cutAction.actionPerformed(e);
            }
        });
        final Action deleteAction = new AbstractAction("Delete") {

            /**
             */
            private static final long serialVersionUID = 4621688037874199553L;

            @Override
            public void actionPerformed(ActionEvent e) {
                deleteSelectedBeans();
            }
        };
        KeyStroke deleteKey = KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0);
        MainKFPerspective.this.getActionMap().put("Delete", deleteAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(deleteKey, "Delete");
        m_deleteB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                deleteAction.actionPerformed(e);
            }
        });
        final Action copyAction = new AbstractAction("Copy") {

            /**
             */
            private static final long serialVersionUID = 117010390180468707L;

            @Override
            public void actionPerformed(ActionEvent e) {
                copyToClipboard();
                m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
            }
        };
        KeyStroke copyKey = KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("Copy", copyAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(copyKey, "Copy");
        m_copyB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                copyAction.actionPerformed(e);
            }
        });
        final Action pasteAction = new AbstractAction("Paste") {

            /**
             */
            private static final long serialVersionUID = 5935121051028929455L;

            @Override
            public void actionPerformed(ActionEvent e) {
                KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
                m_mode = PASTING;
            }
        };
        KeyStroke pasteKey = KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("Paste", pasteAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(pasteKey, "Paste");
        m_pasteB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                pasteAction.actionPerformed(e);
            }
        });
        final Action snapAction = new AbstractAction("Snap") {

            /**
             */
            private static final long serialVersionUID = 7820689847829357449L;

            @Override
            public void actionPerformed(ActionEvent e) {
                // toggle first
                m_snapToGridB.setSelected(!m_snapToGridB.isSelected());
                if (m_snapToGridB.isSelected()) {
                    snapSelectedToGrid();
                }
            }
        };
        KeyStroke snapKey = KeyStroke.getKeyStroke(KeyEvent.VK_G, InputEvent.CTRL_DOWN_MASK);
        MainKFPerspective.this.getActionMap().put("Snap", snapAction);
        MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(snapKey, "Snap");
        m_snapToGridB.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                if (m_snapToGridB.isSelected()) {
                    snapSelectedToGrid();
                }
            }
        });
        fixedTools.setFloatable(false);
        toolBarPanel.add(fixedTools, BorderLayout.EAST);
    }
    final Action noteAction = new AbstractAction("Note") {

        /**
         */
        private static final long serialVersionUID = 2991743619130024875L;

        @Override
        public void actionPerformed(ActionEvent e) {
            Note n = new Note();
            m_toolBarBean = n;
            KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
            m_mode = ADDING;
        }
    };
    KeyStroke noteKey = KeyStroke.getKeyStroke(KeyEvent.VK_I, InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Note", noteAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(noteKey, "Note");
    m_noteB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            noteAction.actionPerformed(e);
        }
    });
    final Action undoAction = new AbstractAction("Undo") {

        /**
         */
        private static final long serialVersionUID = 7248362305594881263L;

        @Override
        public void actionPerformed(ActionEvent e) {
            Stack<File> undo = m_mainKFPerspective.getUndoBuffer();
            if (undo.size() > 0) {
                File undoF = undo.pop();
                if (undo.size() == 0) {
                    m_undoB.setEnabled(false);
                }
                loadLayout(undoF, false, true);
            }
        }
    };
    KeyStroke undoKey = KeyStroke.getKeyStroke(KeyEvent.VK_U, InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Undo", undoAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(undoKey, "Undo");
    m_undoB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            undoAction.actionPerformed(e);
        }
    });
    m_playB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "resultset_next.png")));
    m_playB.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));
    m_playB.setToolTipText("Run this flow (all start points launched in parallel)");
    m_playB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() == 0) {
                return;
            }
            boolean proceed = true;
            if (m_Memory.memoryIsLow()) {
                proceed = m_Memory.showMemoryIsLow();
            }
            if (proceed) {
                runFlow(false);
            }
        }
    });
    m_playBB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "resultset_last.png")));
    m_playBB.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));
    m_playBB.setToolTipText("Run this flow (start points launched sequentially)");
    m_playBB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() == 0) {
                return;
            }
            if (!Utils.getDontShowDialog("weka.gui.beans.KnowledgeFlow.SequentialRunInfo")) {
                JCheckBox dontShow = new JCheckBox("Do not show this message again");
                Object[] stuff = new Object[2];
                stuff[0] = "The order that data sources are launched in can be\n" + "specified by setting a custom name for each data source that\n" + "that includes a number. E.g. \"1:MyArffLoader\". To set a name,\n" + "right-click over a data source and select \"Set name\"\n\n" + "If the prefix is not specified, then the order of execution\n" + "will correspond to the order that the components were added\n" + "to the layout. Note that it is also possible to prevent a data\n" + "source from executing by prefixing its name with a \"!\". E.g\n" + "\"!:MyArffLoader\"";
                stuff[1] = dontShow;
                JOptionPane.showMessageDialog(KnowledgeFlowApp.this, stuff, "Sequential execution information", JOptionPane.OK_OPTION);
                if (dontShow.isSelected()) {
                    try {
                        Utils.setDontShowDialog("weka.gui.beans.KnowledgeFlow.SequentialRunInfo");
                    } catch (Exception ex) {
                    // quietly ignore
                    }
                }
            }
            boolean proceed = true;
            if (m_Memory.memoryIsLow()) {
                proceed = m_Memory.showMemoryIsLow();
            }
            if (proceed) {
                runFlow(true);
            }
        }
    });
    m_stopB = new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "shape_square.png")));
    m_stopB.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
    m_stopB.setToolTipText("Stop all execution");
    Image tempI = loadImage(BeanVisual.ICON_PATH + "cursor.png");
    m_pointerB = new JButton(new ImageIcon(tempI));
    m_pointerB.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));
    m_pointerB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            m_toolBarBean = null;
            m_mode = NONE;
            KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
            m_componentTree.clearSelection();
        }
    });
    // Dimension dP = m_saveB.getPreferredSize();
    // Dimension dM = m_saveB.getMaximumSize();
    // Dimension dP = m_stopB.getPreferredSize();
    // Dimension dM = m_stopB.getMaximumSize();
    // m_pointerB.setPreferredSize(dP);
    // m_pointerB.setMaximumSize(dM);
    // m_toolBarGroup.add(m_pointerB);
    JToolBar fixedTools2 = new JToolBar();
    fixedTools2.setOrientation(JToolBar.HORIZONTAL);
    fixedTools2.setFloatable(false);
    fixedTools2.add(m_pointerB);
    fixedTools2.add(m_playB);
    fixedTools2.add(m_playBB);
    fixedTools2.add(m_stopB);
    Dimension d = m_playB.getPreferredSize();
    Dimension d2 = fixedTools2.getMinimumSize();
    Dimension d3 = new Dimension(d2.width, d.height + 4);
    fixedTools2.setPreferredSize(d3);
    fixedTools2.setMaximumSize(d3);
    // m_helpB.setPreferredSize(dP);
    // m_helpB.setMaximumSize(dP);
    // m_helpB.setSize(m_pointerB.getSize().width,
    // m_pointerB.getSize().height);
    toolBarPanel.add(fixedTools2, BorderLayout.WEST);
    // end modifications by Zerbetto
    m_stopB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            m_logPanel.statusMessage("@!@[KnowledgeFlow]|Attempting to stop all components...");
            stopFlow();
            m_logPanel.statusMessage("@!@[KnowledgeFlow]|OK.");
        }
    });
    final Action helpAction = new AbstractAction("Help") {

        /**
         */
        private static final long serialVersionUID = 3301809940717051925L;

        @Override
        public void actionPerformed(ActionEvent e) {
            popupHelp();
        }
    };
    KeyStroke helpKey = KeyStroke.getKeyStroke(KeyEvent.VK_H, InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Help", helpAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(helpKey, "Help");
    m_helpB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent ae) {
            helpAction.actionPerformed(ae);
        }
    });
    m_templatesB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            createTemplateMenuPopup();
        }
    });
    m_templatesB.setEnabled(BeansProperties.TEMPLATE_PATHS.size() > 0);
    final Action togglePerspectivesAction = new AbstractAction("Toggle perspectives") {

        /**
         */
        private static final long serialVersionUID = 5394622655137498495L;

        @Override
        public void actionPerformed(ActionEvent e) {
            if (m_firstUserComponentOpp) {
                installWindowListenerForSavingUserStuff();
                m_firstUserComponentOpp = false;
            }
            if (!Utils.getDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo")) {
                JCheckBox dontShow = new JCheckBox("Do not show this message again");
                Object[] stuff = new Object[2];
                stuff[0] = "Perspectives are environments that take over the\n" + "Knowledge Flow UI and provide major additional functionality.\n" + "Many perspectives will operate on a set of instances. Instances\n" + "Can be sent to a perspective by placing a DataSource on the\n" + "layout canvas, configuring it and then selecting \"Send to perspective\"\n" + "from the contextual popup menu that appears when you right-click on\n" + "it. Several perspectives are built in to the Knowledge Flow, others\n" + "can be installed via the package manager.\n";
                stuff[1] = dontShow;
                JOptionPane.showMessageDialog(KnowledgeFlowApp.this, stuff, "Perspective information", JOptionPane.OK_OPTION);
                if (dontShow.isSelected()) {
                    try {
                        Utils.setDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo");
                    } catch (Exception ex) {
                    // quietly ignore
                    }
                }
            }
            if (m_configAndPerspectivesVisible) {
                KnowledgeFlowApp.this.remove(m_configAndPerspectives);
                m_configAndPerspectivesVisible = false;
            } else {
                KnowledgeFlowApp.this.add(m_configAndPerspectives, BorderLayout.NORTH);
                m_configAndPerspectivesVisible = true;
            }
            revalidate();
            repaint();
            notifyIsDirty();
        }
    };
    KeyStroke togglePerspectivesKey = KeyStroke.getKeyStroke(KeyEvent.VK_P, InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Toggle perspectives", togglePerspectivesAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(togglePerspectivesKey, "Toggle perspectives");
    m_togglePerspectivesB.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            togglePerspectivesAction.actionPerformed(e);
        }
    });
    final int standard_toolset = 0;
    final int wrapper_toolset = 1;
    int toolBarType = standard_toolset;
    DefaultMutableTreeNode jtreeRoot = new DefaultMutableTreeNode("Weka");
    // set up wrapper toolsets
    for (int i = 0; i < TOOLBARS.size(); i++) {
        Vector<?> tempBarSpecs = TOOLBARS.elementAt(i);
        // name for the tool bar
        String tempToolSetName = (String) tempBarSpecs.elementAt(0);
        DefaultMutableTreeNode subTreeNode = new InvisibleNode(tempToolSetName);
        jtreeRoot.add(subTreeNode);
        // Used for weka leaf packages
        // Box singletonHolderPanel = null;
        // name of the bean component to handle this class of weka algorithms
        String tempBeanCompName = (String) tempBarSpecs.elementAt(1);
        // the root package for weka algorithms
        String rootPackage = "";
        weka.gui.HierarchyPropertyParser hpp = null;
        Hashtable<String, HierarchyPropertyParser> hpps = null;
        // Is this a wrapper toolbar?
        if (tempBeanCompName.compareTo("null") != 0) {
            toolBarType = wrapper_toolset;
            rootPackage = (String) tempBarSpecs.elementAt(2);
            // hpp = (weka.gui.HierarchyPropertyParser)tempBarSpecs.elementAt(3);
            hpps = (Hashtable<String, HierarchyPropertyParser>) tempBarSpecs.elementAt(3);
            try {
                // modifications by Zerbetto
                // Beans.instantiate(null, tempBeanCompName);
                WekaPackageClassLoaderManager.objectForName(tempBeanCompName);
            // Beans.instantiate(this.getClass().getClassLoader(),
            // tempBeanCompName);
            // end modifications by Zerbetto
            } catch (Exception ex) {
                // ignore
                weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING, "[KnowledgeFlow] Failed to instantiate: " + tempBeanCompName);
                break;
            }
        } else {
            toolBarType = standard_toolset;
        }
        // a toolbar to hold buttons---one for each algorithm
        // JToolBar tempToolBar = new JToolBar();
        // System.err.println(tempToolBar.getLayout());
        // tempToolBar.setLayout(new FlowLayout());
        int z = 2;
        if (toolBarType == wrapper_toolset) {
            Enumeration<String> enm = hpps.keys();
            while (enm.hasMoreElements()) {
                String root = enm.nextElement();
                hpp = hpps.get(root);
                if (!hpp.goTo(rootPackage)) {
                }
                String[] primaryPackages = hpp.childrenValues();
                for (String primaryPackage : primaryPackages) {
                    hpp.goToChild(primaryPackage);
                    // sub packages
                    if (hpp.isLeafReached()) {
                        /*
                 * if (singletonHolderPanel == null) { singletonHolderPanel =
                 * Box.createHorizontalBox();
                 * singletonHolderPanel.setBorder(javax
                 * .swing.BorderFactory.createTitledBorder( tempToolSetName)); }
                 */
                        String algName = hpp.fullValue();
                        // -- tempBean = instantiateToolBarBean(true, tempBeanCompName,
                        // algName);
                        Object visibleCheck = instantiateBean((toolBarType == wrapper_toolset), tempBeanCompName, algName);
                        // if (tempBean != null) {
                        if (visibleCheck != null) {
                            /*
                   * Object visibleCheck = instantiateBean((toolBarType ==
                   * wrapper_toolset), tempBeanCompName, algName);
                   */
                            if (visibleCheck instanceof BeanContextChild) {
                                m_bcSupport.add(visibleCheck);
                            }
                            ImageIcon scaledForTree = null;
                            if (visibleCheck instanceof Visible) {
                                BeanVisual bv = ((Visible) visibleCheck).getVisual();
                                if (bv != null) {
                                    scaledForTree = new ImageIcon(bv.scale(0.33));
                                // m_iconLookup.put(algName, scaledForTree);
                                }
                            }
                            // try and get a tool tip
                            String toolTip = "";
                            try {
                                Object wrappedA = WekaPackageClassLoaderManager.objectForName(algName);
                                // Object wrappedA = Class.forName(algName).newInstance();
                                toolTip = getGlobalInfo(wrappedA);
                            } catch (Exception ex) {
                            }
                            JTreeLeafDetails leafData = new JTreeLeafDetails(tempBeanCompName, algName, scaledForTree);
                            if (toolTip != null && toolTip.length() > 0) {
                                leafData.setToolTipText(toolTip);
                            }
                            DefaultMutableTreeNode leafAlgo = new InvisibleNode(leafData);
                            subTreeNode.add(leafAlgo);
                            m_nodeTextIndex.put(algName.toLowerCase() + " " + (toolTip != null ? toolTip.toLowerCase() + " " : ""), leafAlgo);
                        }
                        hpp.goToParent();
                    } else {
                        // make a titledborder JPanel to hold all the schemes in this
                        // package
                        // JPanel holderPanel = new JPanel();
                        /*
                 * Box holderPanel = Box.createHorizontalBox();
                 * holderPanel.setBorder
                 * (javax.swing.BorderFactory.createTitledBorder(userPrefix +
                 * primaryPackages[kk]));
                 */
                        DefaultMutableTreeNode firstLevelOfMainAlgoType = new InvisibleNode(primaryPackage);
                        subTreeNode.add(firstLevelOfMainAlgoType);
                        // processPackage(holderPanel, tempBeanCompName, hpp,
                        // firstLevelOfMainAlgoType);
                        processPackage(tempBeanCompName, hpp, firstLevelOfMainAlgoType, m_nodeTextIndex);
                    // tempToolBar.add(holderPanel);
                    }
                }
            /*
             * if (singletonHolderPanel != null) {
             * tempToolBar.add(singletonHolderPanel); singletonHolderPanel =
             * null; }
             */
            }
        } else {
            for (int j = z; j < tempBarSpecs.size(); j++) {
                tempBeanCompName = (String) tempBarSpecs.elementAt(j);
                Object visibleCheck = instantiateBean((toolBarType == wrapper_toolset), tempBeanCompName, "");
                // if (tempBean != null) {
                if (visibleCheck != null) {
                    // set tool tip text (if any)
                    // setToolTipText(tempBean)
                    // holderPanel.add(tempBean);
                    String treeName = tempBeanCompName;
                    if (treeName.lastIndexOf('.') > 0) {
                        treeName = treeName.substring(treeName.lastIndexOf('.') + 1, treeName.length());
                    }
                    /*
               * Object visibleCheck = instantiateBean((toolBarType ==
               * wrapper_toolset), tempBeanCompName, "");
               */
                    if (visibleCheck instanceof BeanContextChild) {
                        m_bcSupport.add(visibleCheck);
                    }
                    ImageIcon scaledForTree = null;
                    if (visibleCheck instanceof Visible) {
                        BeanVisual bv = ((Visible) visibleCheck).getVisual();
                        if (bv != null) {
                            scaledForTree = new ImageIcon(bv.scale(0.33));
                        // m_iconLookup.put(treeName, scaledForTree);
                        }
                    }
                    String tipText = null;
                    tipText = getGlobalInfo(visibleCheck);
                    // check for annotation and let this override any global info tool
                    // tip
                    Class<?> compClass = visibleCheck.getClass();
                    Annotation[] annotations = compClass.getDeclaredAnnotations();
                    String category = null;
                    DefaultMutableTreeNode targetFolder = null;
                    for (Annotation ann : annotations) {
                        if (ann instanceof KFStep) {
                            tipText = "<html><font color=blue>" + ((KFStep) ann).toolTipText() + "</font></html>";
                            category = ((KFStep) ann).category();
                            // Does this category already exist?
                            Enumeration<TreeNode> children = jtreeRoot.children();
                            while (children.hasMoreElements()) {
                                Object child = children.nextElement();
                                if (child instanceof DefaultMutableTreeNode) {
                                    if (((DefaultMutableTreeNode) child).getUserObject().toString().equals(category)) {
                                        targetFolder = (DefaultMutableTreeNode) child;
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                    }
                    JTreeLeafDetails leafData = new JTreeLeafDetails(tempBeanCompName, "", scaledForTree);
                    if (tipText != null) {
                        leafData.setToolTipText(tipText);
                    }
                    DefaultMutableTreeNode fixedLeafNode = new InvisibleNode(leafData);
                    if (targetFolder != null) {
                        targetFolder.add(fixedLeafNode);
                    } else {
                        subTreeNode.add(fixedLeafNode);
                    }
                    m_nodeTextIndex.put(tempBeanCompName.toLowerCase() + " " + (tipText != null ? tipText.toLowerCase() : ""), fixedLeafNode);
                }
            }
        // tempToolBar.add(holderPanel);
        }
    // JScrollPane tempJScrollPane =
    // createScrollPaneForToolBar(tempToolBar);
    // ok, now create tabbed pane to hold this toolbar
    // m_toolBars.addTab(tempToolSetName, null, tempJScrollPane,
    // tempToolSetName);
    }
    // Any plugin components to process?
    if (BeansProperties.BEAN_PLUGINS_PROPERTIES != null && BeansProperties.BEAN_PLUGINS_PROPERTIES.size() > 0) {
        boolean pluginBeans = false;
        DefaultMutableTreeNode userSubTree = null;
        for (int i = 0; i < BeansProperties.BEAN_PLUGINS_PROPERTIES.size(); i++) {
            Properties tempP = BeansProperties.BEAN_PLUGINS_PROPERTIES.get(i);
            String components = tempP.getProperty("weka.gui.beans.KnowledgeFlow.Plugins");
            if (components != null && components.length() > 0) {
                StringTokenizer st2 = new StringTokenizer(components, ", ");
                while (st2.hasMoreTokens()) {
                    String tempBeanCompName = st2.nextToken().trim();
                    String treeName = tempBeanCompName;
                    if (treeName.lastIndexOf('.') > 0) {
                        treeName = treeName.substring(treeName.lastIndexOf('.') + 1, treeName.length());
                    }
                    // tempBean = instantiateToolBarBean(false, tempBeanCompName, "");
                    /*
               * if (m_pluginsToolBar == null) { // need to create the plugins
               * tab and toolbar setUpPluginsToolBar(); }
               * m_pluginsBoxPanel.add(tempBean);
               */
                    Object visibleCheck = instantiateBean((toolBarType == wrapper_toolset), tempBeanCompName, "");
                    if (visibleCheck instanceof BeanContextChild) {
                        m_bcSupport.add(visibleCheck);
                    }
                    ImageIcon scaledForTree = null;
                    if (visibleCheck instanceof Visible) {
                        BeanVisual bv = ((Visible) visibleCheck).getVisual();
                        if (bv != null) {
                            scaledForTree = new ImageIcon(bv.scale(0.33));
                        // m_iconLookup.put(tempBeanCompName, scaledForTree);
                        }
                    }
                    String tipText = null;
                    tipText = getGlobalInfo(visibleCheck);
                    // check for annotation
                    Class<?> compClass = visibleCheck.getClass();
                    Annotation[] annotations = compClass.getDeclaredAnnotations();
                    DefaultMutableTreeNode targetFolder = null;
                    String category = null;
                    for (Annotation ann : annotations) {
                        if (ann instanceof KFStep) {
                            category = ((KFStep) ann).category();
                            tipText = "<html><font color=red>" + ((KFStep) ann).toolTipText() + "</font></html>";
                            // Does this category already exist?
                            Enumeration<TreeNode> children = jtreeRoot.children();
                            while (children.hasMoreElements()) {
                                Object child = children.nextElement();
                                if (child instanceof DefaultMutableTreeNode) {
                                    if (((DefaultMutableTreeNode) child).getUserObject().toString().equals(category)) {
                                        targetFolder = (DefaultMutableTreeNode) child;
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                    }
                    JTreeLeafDetails leafData = new JTreeLeafDetails(tempBeanCompName, "", scaledForTree);
                    if (tipText != null) {
                        leafData.setToolTipText(tipText);
                    }
                    DefaultMutableTreeNode pluginLeaf = new InvisibleNode(leafData);
                    m_nodeTextIndex.put(tempBeanCompName.toLowerCase() + (tipText != null ? " " + tipText.toLowerCase() : ""), pluginLeaf);
                    if (targetFolder != null) {
                        targetFolder.add(pluginLeaf);
                    } else if (category != null) {
                        // make a new category folder
                        DefaultMutableTreeNode newCategoryNode = new InvisibleNode(category);
                        jtreeRoot.add(newCategoryNode);
                        newCategoryNode.add(pluginLeaf);
                    } else {
                        // add to the default "Plugins" folder
                        if (!pluginBeans) {
                            // make the Plugins tree node entry
                            userSubTree = new InvisibleNode("Plugins");
                            jtreeRoot.add(userSubTree);
                            pluginBeans = true;
                        }
                        userSubTree.add(pluginLeaf);
                    }
                }
            }
            // check for perspectives
            String perspectives = tempP.getProperty(("weka.gui.beans.KnowledgeFlow.Perspectives"));
            if (perspectives != null && perspectives.length() > 0) {
                StringTokenizer st2 = new StringTokenizer(perspectives, ",");
                while (st2.hasMoreTokens()) {
                    String className = st2.nextToken();
                    try {
                        if (PluginManager.isInDisabledList(className)) {
                            continue;
                        }
                        Object p = WekaPackageClassLoaderManager.objectForName(className);
                        // Object p = Class.forName(className).newInstance();
                        if (p instanceof KFPerspective && p instanceof JPanel) {
                            String title = ((KFPerspective) p).getPerspectiveTitle();
                            weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO, "[KnowledgeFlow] loaded perspective: " + title);
                            m_pluginPerspectiveLookup.put(className, title);
                            // not selected as part of the users set of perspectives
                            // yet...
                            ((KFPerspective) p).setLoaded(false);
                            // check to see if user has selected to use this perspective
                            if (BeansProperties.VISIBLE_PERSPECTIVES.contains(className)) {
                                // add to the perspective cache. After processing
                                // all plugins we will iterate over the sorted
                                // VISIBLE_PERSPECTIVES in order to add them
                                // to the toolbar in consistent sorted order
                                // ((KFPerspective)p).setMainKFPerspective(m_mainKFPerspective);
                                m_perspectiveCache.put(className, (KFPerspective) p);
                            }
                        }
                    } catch (Exception ex) {
                        if (m_logPanel != null) {
                            m_logPanel.logMessage("[KnowledgeFlow] WARNING: " + "unable to instantiate perspective \"" + className + "\"");
                            ex.printStackTrace();
                        } else {
                            System.err.println("[KnowledgeFlow] WARNING: " + "unable to instantiate perspective \"" + className + "\"");
                            ex.printStackTrace();
                        }
                    }
                }
            }
        }
    }
    m_togglePerspectivesB.setEnabled(m_pluginPerspectiveLookup.keySet().size() > 0);
    // toolBarPanel.add(m_toolBars, BorderLayout.CENTER);
    // add(m_toolBars, BorderLayout.NORTH);
    add(toolBarPanel, BorderLayout.NORTH);
    // new
    InvisibleTreeModel model = new InvisibleTreeModel(jtreeRoot);
    // DefaultTreeModel(jtreeRoot);
    model.activateFilter(true);
    // subclass JTree so that tool tips can be displayed for leaves (if
    // necessary)
    m_componentTree = new JTree(model) {

        /**
         */
        private static final long serialVersionUID = 6628795889296634120L;

        @Override
        public String getToolTipText(MouseEvent e) {
            if ((getRowForLocation(e.getX(), e.getY())) == -1) {
                return null;
            }
            TreePath currPath = getPathForLocation(e.getX(), e.getY());
            if (currPath.getLastPathComponent() instanceof DefaultMutableTreeNode) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) currPath.getLastPathComponent();
                if (node.isLeaf()) {
                    JTreeLeafDetails leaf = (JTreeLeafDetails) node.getUserObject();
                    return leaf.getToolTipText();
                }
            }
            return null;
        }
    };
    m_componentTree.setEnabled(true);
    m_componentTree.setToolTipText("");
    m_componentTree.setRootVisible(false);
    m_componentTree.setShowsRootHandles(true);
    m_componentTree.setCellRenderer(new BeanIconRenderer());
    DefaultTreeSelectionModel selectionModel = new DefaultTreeSelectionModel();
    selectionModel.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
    m_componentTree.setSelectionModel(selectionModel);
    m_componentTree.addMouseListener(new MouseAdapter() {

        @Override
        public void mouseClicked(MouseEvent e) {
            if (((e.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || e.isAltDown()) {
                boolean clearSelection = true;
                if (clearSelection) {
                    // right click cancels selected component
                    m_toolBarBean = null;
                    m_mode = NONE;
                    KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    m_componentTree.clearSelection();
                }
            }
            TreePath p = m_componentTree.getSelectionPath();
            if (p != null) {
                if (p.getLastPathComponent() instanceof DefaultMutableTreeNode) {
                    DefaultMutableTreeNode tNode = (DefaultMutableTreeNode) p.getLastPathComponent();
                    if (tNode.isLeaf()) {
                        // System.err.println("Selected : " +
                        // tNode.getUserObject().toString());
                        Object userObject = tNode.getUserObject();
                        if (userObject instanceof JTreeLeafDetails) {
                            if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0 && ((JTreeLeafDetails) userObject).isMetaBean()) {
                                if (m_firstUserComponentOpp) {
                                    installWindowListenerForSavingUserStuff();
                                    m_firstUserComponentOpp = false;
                                }
                                Vector<Object> toRemove = ((JTreeLeafDetails) userObject).getMetaBean();
                                DefaultTreeModel model = (DefaultTreeModel) m_componentTree.getModel();
                                MutableTreeNode userRoot = (MutableTreeNode) tNode.getParent();
                                model.removeNodeFromParent(tNode);
                                m_userComponents.remove(toRemove);
                                if (m_userComponents.size() == 0) {
                                    model.removeNodeFromParent(userRoot);
                                    m_userCompNode = null;
                                }
                            } else {
                                ((JTreeLeafDetails) userObject).instantiateBean();
                            }
                        }
                    }
                }
            }
        }
    });
}

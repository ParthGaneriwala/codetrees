private Dimension layoutSize(Container target, boolean preferred) {
    synchronized (target.getTreeLock()) {
        // Each row must fit with the width allocated to the containter.
        // When the container width = 0, the preferred width of the container
        // has not yet been calculated so lets ask for the maximum.
        int targetWidth = target.getSize().width;
        Container container = target;
        while (container.getSize().width == 0 && container.getParent() != null) {
            container = container.getParent();
        }
        targetWidth = container.getSize().width;
        if (targetWidth == 0)
            targetWidth = Integer.MAX_VALUE;
        int hgap = getHgap();
        int vgap = getVgap();
        Insets insets = target.getInsets();
        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
        int maxWidth = targetWidth - horizontalInsetsAndGap;
        // Fit components into the allowed width
        Dimension dim = new Dimension(0, 0);
        int rowWidth = 0;
        int rowHeight = 0;
        int nmembers = target.getComponentCount();
        for (int i = 0; i < nmembers; i++) {
            Component m = target.getComponent(i);
            if (m.isVisible()) {
                Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();
                if (rowWidth + d.width > maxWidth) {
                    addRow(dim, rowWidth, rowHeight);
                    rowWidth = 0;
                    rowHeight = 0;
                }
                if (rowWidth != 0) {
                    rowWidth += hgap;
                }
                rowWidth += d.width;
                rowHeight = Math.max(rowHeight, d.height);
            }
        }
        addRow(dim, rowWidth, rowHeight);
        dim.width += horizontalInsetsAndGap;
        dim.height += insets.top + insets.bottom + vgap * 2;
        // When using a scroll pane or the DecoratedLookAndFeel we need to
        // make sure the preferred size is less than the size of the
        // target containter so shrinking the container size works
        // correctly. Removing the horizontal gap is an easy way to do this.
        Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);
        if (scrollPane != null && target.isValid()) {
            dim.width -= (hgap + 1);
        }
        return dim;
    }
}
